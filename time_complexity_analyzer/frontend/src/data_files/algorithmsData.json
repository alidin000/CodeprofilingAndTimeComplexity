[
  {
    "name": "Insertion Sort",
    "description": "Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time. It is less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. [Learn more](https://en.wikipedia.org/wiki/Insertion_sort)",
    "code": {
      "python": "def insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j >=0 and key < arr[j]:\n                arr[j+1] = arr[j]\n                j -= 1\n        arr[j+1] = key\n    return arr",
      "c++": "void insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}",
      "java": "public void insertionSort(int arr[]) {\n    for (int i=1; i<arr.length; ++i) {\n        int key = arr[i];\n        int j = i-1;\n        while (j>=0 && arr[j] > key) {\n            arr[j+1] = arr[j];\n            j = j-1;\n        }\n        arr[j+1] = key;\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/8oJS1BMKE64?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei\" title=\"Insertion Sort\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of sorting algorithm is Insertion Sort?",
        "options": ["Insertion Sort is a comparison-based sorting algorithm.", "Insertion Sort is a distribution-based sorting algorithm.", "Insertion Sort is a non-comparison-based sorting algorithm."],
        "answer": "Insertion Sort is a comparison-based sorting algorithm."
      },
      {
        "question": "What is the best case time complexity of Insertion Sort?",
        "options": ["O(n^2)", "O(n log n)", "O(n)"],
        "answer": "O(n) when the array is already sorted."
      }
    ]
  },
  {
    "name": "Selection Sort",
    "description": "Selection Sort is an in-place comparison-based algorithm in which the list is divided into two parts: the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list. [Learn more](https://en.wikipedia.org/wiki/Selection_sort)",
    "code": {
      "python": "def selectionSort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[min_idx] > arr[j]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
      "c++": "void selectionSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++)\n            if (arr[j] < arr[min_idx])\n                min_idx = j;\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}",
      "java": "public void selectionSort(int arr[]) {\n    for (int i = 0; i < arr.length-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < arr.length; j++)\n            if (arr[min_idx] > arr[j])\n                min_idx = j;\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/92BfuxHn2XE?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei\" title=\"Selection Sort\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Selection Sort?",
        "options": ["Selection Sort is a comparison-based sorting algorithm.", "Selection Sort is a distribution-based sorting algorithm.", "Selection Sort is a non-comparison-based sorting algorithm."],
        "answer": "Selection Sort is a comparison-based sorting algorithm."
      },
      {
        "question": "What is the time complexity of Selection Sort in all cases?",
        "options": ["O(n)", "O(n log n)", "O(n^2)"],
        "answer": "O(n^2) in all cases, making it inefficient on large lists."
      }
    ]
  },
  {
    "name": "Heap Sort",
    "description": "Heap Sort is a comparison-based sorting technique based on a Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place it at the end. This process is repeated for the remaining elements. [Learn more](https://en.wikipedia.org/wiki/Heapsort)",
    "code": {
      "python": "def heapSort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and arr[l] > arr[largest]:\n            largest = l\n\n        if r < n and arr[r] > arr[largest]:\n            largest = r\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, n-i, 0)\n    return arr",
      "c++": "void heapSort(int arr[], int n) {\n    auto heapify = [&](int arr[], int n, int i) {\n        int largest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n\n        if (l < n && arr[l] > arr[largest])\n            largest = l;\n        if (r < n && arr[r] > arr[largest])\n            largest = r;\n\n        if (largest != i) {\n            std::swap(arr[i], arr[largest]);\n            heapify(arr, n, largest);\n        }\n    };\n\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        std::swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}",
      "java": "public void heapSort(int arr[]) {\n    void heapify(int arr[], int n, int i) {\n        int largest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n\n        if (l < n && arr[l] > arr[largest])\n            largest = l;\n        if (r < n && arr[r] > arr[largest])\n            largest = r;\n\n        if (largest != i) {\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n            heapify(arr, n, largest);\n        }\n    }\n    int n = arr.length;\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/_bkow6IykGM?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei\" title=\"Heap Sort\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of sorting algorithm is Heap Sort?",
        "options": ["Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure.", "Heap Sort is a distribution-based sorting algorithm.", "Heap Sort is a non-comparison-based sorting algorithm."],
        "answer": "Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure."
      },
      {
        "question": "What is the time complexity of Heap Sort?",
        "options": ["O(n)", "O(n log n)", "O(n^2)"],
        "answer": "O(n log n) for all cases."
      }
    ]
  },
  {
    "name": "Bubble Sort",
    "description": "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. [Learn more](https://en.wikipedia.org/wiki/Bubble_sort)",
    "code": {
      "python": "def bubbleSort(arr):\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
      "c++": "void bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1])\n                std::swap(arr[j], arr[j+1]);\n}",
      "java": "public void bubbleSort(int arr[]) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/Cq7SMsQBEUw?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei\" title=\"Bubble Sort\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Bubble Sort?",
        "options": ["Bubble Sort is a comparison-based sorting algorithm.", "Bubble Sort is a distribution-based sorting algorithm.", "Bubble Sort is a non-comparison-based sorting algorithm."],
        "answer": "Bubble Sort is a comparison-based sorting algorithm."
      },
      {
        "question": "What is the time complexity of Bubble Sort in the worst case?",
        "options": ["O(n)", "O(n log n)", "O(n^2)"],
        "answer": "O(n^2)"
      }
    ]
  },
  {
    "name": "Quick Sort",
    "description": "Quick Sort is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare, it works by partitioning an array into two sub-arrays, then sorting the sub-arrays independently. [Learn more](https://en.wikipedia.org/wiki/Quicksort)",
    "code": {
      "python": "def quickSort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quickSort(left) + middle + quickSort(right)",
      "c++": "int partition (int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high-1; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            std::swap(arr[i], arr[j]);\n        }\n    }\n    std::swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}",
      "java": "int partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return i + 1;\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/8hEyhs3OV1w?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei\" title=\"Quick Sort (LR pointers)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is the average time complexity of Quick Sort?",
        "options": ["O(n^2)", "O(n log n)", "O(n)"],
        "answer": "O(n log n)"
      },
      {
        "question": "What is the key concept behind Quick Sort?",
        "options": ["Merging sorted arrays", "Partitioning the array around a pivot element", "Repeatedly swapping adjacent elements"],
        "answer": "Partitioning the array around a pivot element"
      }
    ]
  },
  {
    "name": "Merge Sort",
    "description": "Merge Sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm. Most implementations produce a stable sort, meaning that the implementation preserves the input order of equal elements in the sorted output. [Learn more](https://en.wikipedia.org/wiki/Merge_sort)",
    "code": {
      "python": "def mergeSort(arr):\n    if len(arr) > 1:\n        mid = len(arr)//2\n        L = arr[:mid]\n        R = arr[mid:]\n        mergeSort(L)\n        mergeSort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return arr",
      "c++": "void merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}",
      "java": "void merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[] = new int[n1];\n    int R[] = new int[n2];\n    for (int i = 0; i < n1; ++i)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; ++j)\n        R[j] = arr[m + 1 + j];\n    int i = 0, j = 0;\n    int k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = (l + r) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}"
    },
    "video": "<iframe width='900' height='500' src='https://www.youtube.com/embed/ZRPoEKHXTJg?list=PLZh3kxyHrVp_AcOanN_jpuQbcMVdXbqei' title='Merge Sort' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Merge Sort?",
        "options": ["Merge Sort is a comparison-based sorting algorithm.", "Merge Sort is a distribution-based sorting algorithm.", "Merge Sort is a non-comparison-based sorting algorithm."],
        "answer": "Merge Sort is a comparison-based sorting algorithm."
      },
      {
        "question": "What is the time complexity of Merge Sort?",
        "options": ["O(n^2)", "O(n log n)", "O(n)"],
        "answer": "O(n log n)"
      }
    ]
  },
  {
    "name": "Linked List",
    "description": "A Linked List is a linear data structure in which elements are stored in nodes, and each node contains a reference (or link) to the next node in the sequence. Linked lists are dynamic and can easily grow and shrink in size by allocating and deallocating memory during runtime. [Learn more](https://en.wikipedia.org/wiki/Linked_list)",
    "code": {
      "python": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node",
      "c++": "class Node {\npublic:\n    int data;\n    Node* next;\n    Node(int data) {\n        this->data = data;\n        this->next = nullptr;\n    }\n};\n\nclass LinkedList {\npublic:\n    Node* head;\n    LinkedList() { head = nullptr; }\n\n    void insert(int data) {\n        Node* new_node = new Node(data);\n        new_node->next = head;\n        head = new_node;\n    }\n};",
      "java": "class Node {\n    int data;\n    Node next;\n    Node(int data) { this.data = data; this.next = null; }\n}\n\nclass LinkedList {\n    Node head;\n    void insert(int data) {\n        Node new_node = new Node(data);\n        new_node.next = head;\n        head = new_node;\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/OjhiiIea8X8?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Singly Linked List Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Linked List?",
        "options": ["A data structure consisting of nodes that contain data and a reference to the next node.", "A data structure consisting of a sequence of elements in a fixed order.", "A data structure used to store key-value pairs."],
        "answer": "A data structure consisting of nodes that contain data and a reference to the next node."
      },
      {
        "question": "What is the time complexity of inserting an element at the beginning of a Linked List?",
        "options": ["O(1)", "O(log n)", "O(n)"],
        "answer": "O(1)"
      }
    ]
  },
  {
    "name": "Binary Search Tree (BST)",
    "description": "A Binary Search Tree (BST) is a node-based binary tree data structure which has the following properties: the left subtree of a node contains only nodes with keys lesser than the node’s key, the right subtree contains only nodes with keys greater than the node’s key, and both the left and right subtrees must also be binary search trees. [Learn more](https://en.wikipedia.org/wiki/Binary_search_tree)",
    "code": {
      "python": "class Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n    def insert(self, key):\n        if self.val:\n            if key < self.val:\n                if self.left is None:\n                    self.left = Node(key)\n                else:\n                    self.left.insert(key)\n            elif key > self.val:\n                if self.right is None:\n                    self.right = Node(key)\n                else:\n                    self.right.insert(key)\n        else:\n            self.val = key",
      "c++": "class Node {\npublic:\n    int key;\n    Node* left, *right;\n    Node(int item) {\n        key = item;\n        left = right = nullptr;\n    }\n};\n\nclass BST {\npublic:\n    Node* root;\n    BST() { root = nullptr; }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\nprivate:\n    Node* insertRec(Node* root, int key) {\n        if (root == nullptr) {\n            root = new Node(key);\n            return root;\n        }\n        if (key < root->key)\n            root->left = insertRec(root->left, key);\n        else if (key > root->key)\n            root->right = insertRec(root->right, key);\n        return root;\n    }\n};",
      "java": "class Node {\n    int key;\n    Node left, right;\n    public Node(int item) {\n        key = item;\n        left = right = null;\n    }\n}\n\nclass BST {\n    Node root;\n    BST() { root = null; }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n        return root;\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/ymGjUOiR8Jg?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Binary Search Tree Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Binary Search Tree (BST)?",
        "options": ["A tree data structure in which each node has at most two children, which are referred to as the left child and the right child.", "A linear data structure where elements are stored in a sequential manner.", "A tree data structure used for hash tables."],
        "answer": "A tree data structure in which each node has at most two children, which are referred to as the left child and the right child."
      },
      {
        "question": "What is the time complexity of searching an element in a Binary Search Tree?",
        "options": ["O(1)", "O(log n)", "O(n)"],
        "answer": "O(log n)"
      }
    ]
  },
  {
    "name": "Stack",
    "description": "A Stack is a linear data structure that follows the LIFO (Last In, First Out) principle, where elements are added and removed from the same end. It can be implemented using arrays or linked lists. [Learn more](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))",
    "code": {
      "python": "class Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, item):\n        self.stack.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.stack.pop()\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def peek(self):\n        if not self.is_empty():\n            return self.stack[-1]\n\n    def size(self):\n        return len(self.stack)",
      "c++": "#include <iostream>\n#include <vector>\n\nclass Stack {\nprivate:\n    std::vector<int> stack;\npublic:\n    void push(int item) {\n        stack.push_back(item);\n    }\n\n    int pop() {\n        if (!is_empty()) {\n            int item = stack.back();\n            stack.pop_back();\n            return item;\n        }\n        return -1; // Stack is empty\n    }\n\n    bool is_empty() {\n        return stack.empty();\n    }\n\n    int peek() {\n        if (!is_empty()) {\n            return stack.back();\n        }\n        return -1; // Stack is empty\n    }\n\n    int size() {\n        return stack.size();\n    }\n};",
      "java": "import java.util.Stack;\n\npublic class StackExample {\n    public static void main(String[] args) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        System.out.println(stack.pop()); // 3\n        System.out.println(stack.peek()); // 2\n        System.out.println(stack.isEmpty()); // false\n        System.out.println(stack.size()); // 2\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/-qsKQVpGPKs?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Stack Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Stack?",
        "options": ["A linear data structure that follows the LIFO (Last In, First Out) principle.", "A linear data structure that follows the FIFO (First In, First Out) principle.", "A tree-based data structure."],
        "answer": "A linear data structure that follows the LIFO (Last In, First Out) principle."
      },
      {
        "question": "What operation removes an element from a Stack?",
        "options": ["Push", "Pop", "Peek"],
        "answer": "Pop"
      }
    ]
  },
  {
    "name": "Queue",
    "description": "A Queue is a linear data structure that follows the FIFO (First In, First Out) principle, where the element added first is the first one to be removed. It can be implemented using arrays or linked lists. [Learn more](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))",
    "code": {
      "python": "class Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item):\n        self.queue.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.pop(0)\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)",
      "c++": "#include <iostream>\n#include <queue>\n\nclass Queue {\nprivate:\n    std::queue<int> queue;\npublic:\n    void enqueue(int item) {\n        queue.push(item);\n    }\n\n    int dequeue() {\n        if (!is_empty()) {\n            int item = queue.front();\n            queue.pop();\n            return item;\n        }\n        return -1; // Queue is empty\n    }\n\n    bool is_empty() {\n        return queue.empty();\n    }\n\n    int size() {\n        return queue.size();\n    }\n};",
      "java": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class QueueExample {\n    public static void main(String[] args) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        System.out.println(queue.remove()); // 1\n        System.out.println(queue.peek()); // 2\n        System.out.println(queue.isEmpty()); // false\n        System.out.println(queue.size()); // 2\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/agQQyKd0HBQ?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Queue Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Queue?",
        "options": ["A linear data structure that follows the FIFO (First In, First Out) principle.", "A linear data structure that follows the LIFO (Last In, First Out) principle.", "A tree-based data structure."],
        "answer": "A linear data structure that follows the FIFO (First In, First Out) principle."
      },
      {
        "question": "What operation removes an element from a Queue?",
        "options": ["Enqueue", "Dequeue", "Peek"],
        "answer": "Dequeue"
      }
    ]
  },
  {
    "name": "Priority Queue",
    "description": "A Priority Queue is an abstract data type similar to a regular queue or stack data structure, but where each element has a priority. Elements with higher priority are dequeued before elements with lower priority. [Learn more](https://en.wikipedia.org/wiki/Priority_queue)",
    "code": {
      "python": "import heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.pq = []\n\n    def push(self, item):\n        heapq.heappush(self.pq, item)\n\n    def pop(self):\n        return heapq.heappop(self.pq)\n\n    def peek(self):\n        return self.pq[0]\n\n    def is_empty(self):\n        return len(self.pq) == 0",
      "c++": "#include <queue>\n#include <vector>\n\nclass PriorityQueue {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;\npublic:\n    void push(int item) {\n        pq.push(item);\n    }\n\n    int pop() {\n        int top = pq.top();\n        pq.pop();\n        return top;\n    }\n\n    int peek() {\n        return pq.top();\n    }\n\n    bool is_empty() {\n        return pq.empty();\n    }\n};",
      "java": "import java.util.PriorityQueue;\n\npublic class PriorityQueueExample {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        pq.add(3);\n        pq.add(1);\n        pq.add(2);\n        System.out.println(pq.peek()); // 1\n        System.out.println(pq.poll()); // 1\n        System.out.println(pq.peek()); // 2\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/-D6JYBrVrhs?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Priority Queue Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Priority Queue?",
        "options": ["A data structure where each element is associated with a priority.", "A linear data structure that follows the FIFO principle.", "A linear data structure that follows the LIFO principle."],
        "answer": "A data structure where each element is associated with a priority."
      },
      {
        "question": "What operation retrieves the highest priority element from a Priority Queue?",
        "options": ["Push", "Pop", "Peek"],
        "answer": "Pop"
      }
    ]
  },
  {
    "name": "Trie",
    "description": "A Trie, also known as a prefix tree, is a type of search tree, a tree data structure used for locating specific keys from within a set. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. [Learn more](https://en.wikipedia.org/wiki/Trie)",
    "code": {
      "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word",
      "c++": "#include <iostream>\n#include <unordered_map>\n\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n    bool is_end_of_word;\n    TrieNode() : is_end_of_word(false) {}\n};\n\nclass Trie {\n    TrieNode* root;\npublic:\n    Trie() { root = new TrieNode(); }\n\n    void insert(const std::string& word) {\n        TrieNode* node = root;\n        for (char ch : word) {\n            if (!node->children.count(ch)) {\n                node->children[ch] = new TrieNode();\n            }\n            node = node->children[ch];\n        }\n        node->is_end_of_word = true;\n    }\n\n    bool search(const std::string& word) {\n        TrieNode* node = root;\n        for (char ch : word) {\n            if (!node->children.count(ch)) {\n                return false;\n            }\n            node = node->children[ch];\n        }\n        return node->is_end_of_word;\n    }\n};",
      "java": "import java.util.HashMap;\nimport java.util.Map;\n\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEndOfWord = false;\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char ch : word.toCharArray()) {\n            node = node.children.computeIfAbsent(ch, c -> new TrieNode());\n        }\n        node.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char ch : word.toCharArray()) {\n            node = node.children.get(ch);\n            if (node == null) {\n                return false;\n            }\n        }\n        return node.isEndOfWord;\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/dUBkaqrcYT8\" title=\"Trie - Insert and Search | GeeksforGeeks\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Trie?",
        "options": ["A tree-like data structure used for storing a dynamic set of strings.", "A data structure that implements an associative array abstract data type.", "A double-ended queue that allows insertion and removal of elements from both ends."],
        "answer": "A tree-like data structure used for storing a dynamic set of strings."
      },
      {
        "question": "What is the time complexity of searching for a word in a Trie?",
        "options": ["O(1)", "O(n)", "O(m)", "O(m * n)"],
        "answer": "O(m) where m is the length of the word."
      }
    ]
  },
  {
    "name": "Heap",
    "description": "A Heap is a special tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. The node at the 'top' of the heap (with no parents) is called the root node. [Learn more](https://en.wikipedia.org/wiki/Heap_(data_structure))",
    "code": {
      "python": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.__heapify_up(len(self.heap) - 1)\n\n    def __heapify_up(self, index):\n        parent = (index - 1) // 2\n        if index > 0 and self.heap[index] > self.heap[parent]:\n            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]\n            self.__heapify_up(parent)",
      "c++": "class Heap {\n    vector<int> h;\npublic:\n    void insert(int val) {\n        h.push_back(val);\n        heapify_up(h.size() - 1);\n    }\nprivate:\n    void heapify_up(int i) {\n        int parent = (i - 1) / 2;\n        if (i && h[parent] < h[i]) {\n            swap(h[i], h[parent]);\n            heapify_up(parent);\n        }\n    }\n};",
      "java": "class Heap {\n    private int[] Heap;\n    private int size;\n    private int maxsize;\n\n    public Heap(int maxsize) {\n        this.maxsize = maxsize;\n        this.size = 0;\n        Heap = new int[this.maxsize + 1];\n        Heap[0] = Integer.MAX_VALUE;\n    }\n\n    private void heapifyUp(int pos) {\n        int parentPos = pos / 2;\n        if (pos > 1 && Heap[pos] > Heap[parentPos]) {\n            int tmp;\n            tmp = Heap[pos];\n            Heap[pos] = Heap[parentPos];\n            Heap[parentPos] = tmp;\n            heapifyUp(parentPos);\n        }\n    }\n\n    public void insert(int element) {\n        Heap[++size] = element;\n        heapifyUp(size);\n    }\n}"
    },
    "video": "<iframe width='900' height='500' src='https://www.youtube.com/embed/uU0iWaVxMgc?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x' title='Max Heap Animations | Data Structure | Visual How' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Heap?",
        "options": ["A special tree-based data structure that satisfies the heap property.", "A linear data structure where elements are stored in a sequential manner.", "A tree data structure used for hash tables."],
        "answer": "A special tree-based data structure that satisfies the heap property."
      },
      {
        "question": "What is the time complexity of inserting an element into a Heap?",
        "options": ["O(1)", "O(log n)", "O(n)"],
        "answer": "O(log n)"
      }
    ]
  },
  {
    "name": "Hash Table",
    "description": "A Hash Table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. Hash tables use a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. [Learn more](https://en.wikipedia.org/wiki/Hash_table)",
    "code": {
      "python": "class HashTable:\n    def __init__(self):\n        self.table = [None] * 10\n\n    def hash(self, key):\n        return hash(key) % len(self.table)\n\n    def insert(self, key, value):\n        index = self.hash(key)\n        self.table[index] = value",
      "c++": "#include <vector>\n#include <list>\n\nclass HashTable {\n    std::vector<std::list<std::pair<int, int>>> table;\npublic:\n    HashTable() : table(10) {}\n\n    int hash(int key) {\n        return key % table.size();\n    }\n\n    void insert(int key, int value) {\n        int index = hash(key);\n        table[index].push_back({key, value});\n    }\n};",
      "java": "import java.util.LinkedList;\n\nclass HashTable {\n    private LinkedList<Entry>[] table;\n\n    static class Entry {\n        int key;\n        int value;\n\n        Entry(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    public HashTable() {\n        table = new LinkedList[10];\n        for (int i = 0; i < table.length; i++) {\n            table[i] = new LinkedList<>();\n        }\n    }\n\n    private int hash(int key) {\n        return key % table.length;\n    }\n\n    public void insert(int key, int value) {\n        int index = hash(key);\n        table[index].add(new Entry(key, value));\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/VeYKEMY2F9k?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Hashing Animations | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Hash Table?",
        "options": ["A data structure that implements an associative array abstract data type.", "A linear data structure where elements are stored in a sequential manner.", "A special tree-based data structure that satisfies the heap property."],
        "answer": "A data structure that implements an associative array abstract data type."
      },
      {
        "question": "What is the time complexity of inserting an element into a Hash Table in the average case?",
        "options": ["O(1)", "O(log n)", "O(n)"],
        "answer": "O(1)"
      }
    ]
  },
  {
    "name": "Dijkstra's Algorithm",
    "description": "Dijkstra's Algorithm is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. [Learn more](https://en.wikipedia.org/wiki/Dijkstra's_algorithm)",
    "code": {
      "python": "import heapq\n\ndef dijkstra(graph, start):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances",
      "c++": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n\nconst int INF = 1e9;\n\nvoid dijkstra(int start, std::vector<std::vector<std::pair<int, int>>>& graph) {\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> pq;\n    std::vector<int> distance(graph.size(), INF);\n    pq.push({0, start});\n    distance[start] = 0;\n    while (!pq.empty()) {\n        int current_distance = pq.top().first;\n        int current_node = pq.top().second;\n        pq.pop();\n        if (current_distance > distance[current_node]) continue;\n        for (auto& edge : graph[current_node]) {\n            int neighbor = edge.first;\n            int weight = edge.second;\n            if (current_distance + weight < distance[neighbor]) {\n                distance[neighbor] = current_distance + weight;\n                pq.push({distance[neighbor], neighbor});\n            }\n        }\n    }\n    for (int i = 0; i < distance.size(); ++i)\n        std::cout << \"Distance to node \" << i << \" is \" << distance[i] << std::endl;\n}",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Edge>[] adj;\n\n    static class Edge {\n        int node;\n        int weight;\n        Edge(int node, int weight) { this.node = node; this.weight = weight; }\n    }\n\n    Graph(int V) {\n        this.V = V;\n        adj = new LinkedList[V];\n        for (int i = 0; i < V; ++i)\n            adj[i] = new LinkedList<>();\n    }\n\n    void addEdge(int u, int v, int weight) {\n        adj[u].add(new Edge(v, weight));\n    }\n\n    void dijkstra(int src) {\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n        int[] dist = new int[V];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        pq.add(new Edge(src, 0));\n        dist[src] = 0;\n        while (!pq.isEmpty()) {\n            Edge edge = pq.poll();\n            int u = edge.node;\n            for (Edge neighbor : adj[u]) {\n                int v = neighbor.node;\n                int weight = neighbor.weight;\n                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.add(new Edge(v, dist[v]));\n                }\n            }\n        }\n        for (int i = 0; i < V; ++i)\n            System.out.println(\"Distance to node \" + i + \" is \" + dist[i]);\n    }\n}"
    },
    "video": "<iframe width='900' height='500' src='https://www.youtube.com/embed/F9PEKv59anQ' title='Crude Dijkstra Visualization' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is Dijkstra's Algorithm used for?",
        "options": ["Finding the shortest paths between nodes in a graph.", "Finding the minimum spanning tree of a graph.", "Sorting elements in an array."],
        "answer": "Finding the shortest paths between nodes in a graph."
      },
      {
        "question": "What is the time complexity of Dijkstra's Algorithm using a priority queue?",
        "options": ["O(V^2)", "O(E log V)", "O(V log V)"],
        "answer": "O(E log V)"
      }
    ]
  },
  {
    "name": "Depth-First Search (DFS)",
    "description": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking. [Learn more](https://en.wikipedia.org/wiki/Depth-first_search)",
    "code": {
      "python": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    return visited",
      "c++": "void DFSUtil(int v, bool visited[], std::vector<int> adj[]) {\n    visited[v] = true;\n    std::cout << v << \" \";\n    for (int i : adj[v])\n        if (!visited[i])\n            DFSUtil(i, visited, adj);\n}\n\nvoid DFS(int V, std::vector<int> adj[]) {\n    bool* visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n    for (int i = 0; i < V; i++)\n        if (!visited[i])\n            DFSUtil(i, visited, adj);\n}",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Integer> adj[];\n\n    Graph(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n    }\n\n    void DFSUtil(int v, boolean visited[]) {\n        visited[v] = true;\n        System.out.print(v + \" \");\n        Iterator<Integer> i = adj[v].listIterator();\n        while (i.hasNext()) {\n            int n = i.next();\n            if (!visited[n])\n                DFSUtil(n, visited);\n        }\n    }\n\n    void DFS() {\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; ++i)\n            if (!visited[i])\n                DFSUtil(i, visited);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/3_NMDJkmvLo?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Depth First Search (DFS) Animations | Graph Traversal | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Depth-First Search (DFS)?",
        "options": ["A graph traversal algorithm.", "A sorting algorithm.", "A dynamic programming algorithm."],
        "answer": "A graph traversal algorithm."
      },
      {
        "question": "What data structure is commonly used to implement DFS?",
        "options": ["Queue", "Stack", "Heap"],
        "answer": "Stack"
      }
    ]
  },
  {
    "name": "Breadth-First Search (BFS)",
    "description": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or an arbitrary node in the case of a graph) and explores the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. [Learn more](https://en.wikipedia.org/wiki/Breadth-first_search)",
    "code": {
      "python": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        vertex = queue.popleft()\n        print(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)",
      "c++": "#include <iostream>\n#include <list>\n#include <queue>\n\nvoid BFS(int start, std::vector<int> adj[], int V) {\n    std::vector<bool> visited(V, false);\n    std::queue<int> queue;\n    visited[start] = true;\n    queue.push(start);\n    while (!queue.empty()) {\n        int v = queue.front();\n        std::cout << v << \" \";\n        queue.pop();\n        for (int i : adj[v]) {\n            if (!visited[i]) {\n                visited[i] = true;\n                queue.push(i);\n            }\n        }\n    }\n}",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Integer> adj[];\n\n    Graph(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n    }\n\n    void BFS(int s) {\n        boolean visited[] = new boolean[V];\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n        visited[s] = true;\n        queue.add(s);\n        while (queue.size() != 0) {\n            s = queue.poll();\n            System.out.print(s + \" \");\n            Iterator<Integer> i = adj[s].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (!visited[n]) {\n                    visited[n] = true;\n                    queue.add(n);\n                }\n            }\n        }\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/QUfEOCOEKkc?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Breadth First Search (BFS) Animations | Graph Traversal | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Breadth-First Search (BFS)?",
        "options": ["A graph traversal algorithm.", "A sorting algorithm.", "A dynamic programming algorithm."],
        "answer": "A graph traversal algorithm."
      },
      {
        "question": "What data structure is commonly used to implement BFS?",
        "options": ["Queue", "Stack", "Heap"],
        "answer": "Queue"
      }
    ]
  },
  {
    "name": "Graph",
    "description": "A Graph is a data structure that consists of a finite set of vertices (or nodes) and a set of edges connecting them. Graphs can be used to represent various real-world networks such as computer networks, social networks, and transportation systems. [Learn more](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))",
    "code": {
      "python": "class Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_edge(self, u, v):\n        if u not in self.graph:\n            self.graph[u] = []\n        self.graph[u].append(v)\n\n    def bfs(self, start):\n        visited = set()\n        queue = [start]\n        while queue:\n            vertex = queue.pop(0)\n            if vertex not in visited:\n                print(vertex)\n                visited.add(vertex)\n                queue.extend(set(self.graph[vertex]) - visited)\n\n    def dfs(self, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        print(start)\n        for next in set(self.graph[start]) - visited:\n            self.dfs(next, visited)",
      "c++": "#include <iostream>\n#include <list>\n#include <queue>\n\nclass Graph {\n    int V;\n    std::list<int>* adj;\npublic:\n    Graph(int V) {\n        this->V = V;\n        adj = new std::list<int>[V];\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    void BFS(int s) {\n        bool* visited = new bool[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n        std::queue<int> queue;\n        visited[s] = true;\n        queue.push(s);\n        while (!queue.empty()) {\n            s = queue.front();\n            std::cout << s << \" \";\n            queue.pop();\n            for (auto adjecent : adj[s]) {\n                if (!visited[adjecent]) {\n                    visited[adjecent] = true;\n                    queue.push(adjecent);\n                }\n            }\n        }\n    }\n\n    void DFSUtil(int v, bool visited[]) {\n        visited[v] = true;\n        std::cout << v << \" \";\n        for (auto i = adj[v].begin(); i != adj[v].end(); ++i)\n            if (!visited[*i])\n                DFSUtil(*i, visited);\n    }\n\n    void DFS(int v) {\n        bool* visited = new bool[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n        DFSUtil(v, visited);\n    }\n};",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Integer> adj[];\n\n    Graph(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n    }\n\n    void BFS(int s) {\n        boolean visited[] = new boolean[V];\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n        visited[s] = true;\n        queue.add(s);\n        while (queue.size() != 0) {\n            s = queue.poll();\n            System.out.print(s + \" \");\n            Iterator<Integer> i = adj[s].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (!visited[n]) {\n                    visited[n] = true;\n                    queue.add(n);\n                }\n            }\n        }\n    }\n\n    void DFSUtil(int v, boolean visited[]) {\n        visited[v] = true;\n        System.out.print(v + \" \");\n        Iterator<Integer> i = adj[v].listIterator();\n        while (i.hasNext()) {\n            int n = i.next();\n            if (!visited[n])\n                DFSUtil(n, visited);\n        }\n    }\n\n    void DFS(int v) {\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; ++i)\n            if (!visited[i])\n                DFSUtil(i, visited);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/sf17xiYfLcM?list=PLFonK3OU1E4qVvtRGBSL0xtXOmzZkLy8x\" title=\"Adjacency List Animations | Graph Representation | Data Structure | Visual How\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is a Graph?",
        "options": ["A data structure that consists of a finite set of vertices (or nodes) and a set of edges connecting them.", "A tree-based data structure.", "A linear data structure that follows the FIFO principle."],
        "answer": "A data structure that consists of a finite set of vertices (or nodes) and a set of edges connecting them."
      },
      {
        "question": "What are the two main types of Graph traversals?",
        "options": ["In-order and Pre-order", "BFS and DFS", "Linear and Non-linear"],
        "answer": "BFS and DFS"
      }
    ]
  },
  {
    "name": "Kruskal's Algorithm",
    "description": "Kruskal's Algorithm is a minimum spanning tree algorithm that finds an edge of the least possible weight that connects any two trees in the forest. It is a greedy algorithm in graph theory that finds a minimum spanning tree for a connected weighted graph. [Learn more](https://en.wikipedia.org/wiki/Kruskal's_algorithm)",
    "code": {
      "python": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def addEdge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def find(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.find(parent, parent[i])\n\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def KruskalMST(self):\n        result = []\n        i, e = 0, 0\n        self.graph = sorted(self.graph, key=lambda item: item[2])\n        parent = []\n        rank = []\n        for node in range(self.V):\n            parent.append(node)\n            rank.append(0)\n        while e < self.V - 1:\n            u, v, w = self.graph[i]\n            i = i + 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n            if x != y:\n                e = e + 1\n                result.append([u, v, w])\n                self.union(parent, rank, x, y)\n        return result",
      "c++": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(const Edge& other) const {\n        return weight < other.weight;\n    }\n};\n\nclass Graph {\n    int V;\n    std::vector<Edge> edges;\npublic:\n    Graph(int V) : V(V) {}\n    void addEdge(int u, int v, int w) {\n        edges.push_back({u, v, w});\n    }\n\n    int find(std::vector<int>& parent, int i) {\n        if (parent[i] == i)\n            return i;\n        return parent[i] = find(parent, parent[i]);\n    }\n\n    void unionSets(std::vector<int>& parent, std::vector<int>& rank, int x, int y) {\n        int xroot = find(parent, x);\n        int yroot = find(parent, y);\n        if (rank[xroot] < rank[yroot])\n            parent[xroot] = yroot;\n        else if (rank[xroot] > rank[yroot])\n            parent[yroot] = xroot;\n        else {\n            parent[yroot] = xroot;\n            rank[xroot]++;\n        }\n    }\n\n    void KruskalMST() {\n        std::sort(edges.begin(), edges.end());\n        std::vector<int> parent(V);\n        std::vector<int> rank(V, 0);\n        for (int i = 0; i < V; ++i)\n            parent[i] = i;\n        std::vector<Edge> result;\n        for (const auto& edge : edges) {\n            int x = find(parent, edge.u);\n            int y = find(parent, edge.v);\n            if (x != y) {\n                result.push_back(edge);\n                unionSets(parent, rank, x, y);\n            }\n        }\n        for (const auto& edge : result)\n            std::cout << edge.u << \" - \" << edge.v << \" : \" << edge.weight << std::endl;\n    }\n};",
      "java": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int src, dest, weight;\n    public int compareTo(Edge compareEdge) {\n        return this.weight - compareEdge.weight;\n    }\n}\n\nclass Subset {\n    int parent, rank;\n}\n\nclass Graph {\n    int V, E;\n    Edge edge[];\n\n    Graph(int v, int e) {\n        V = v;\n        E = e;\n        edge = new Edge[E];\n        for (int i = 0; i < e; ++i)\n            edge[i] = new Edge();\n    }\n\n    int find(Subset subsets[], int i) {\n        if (subsets[i].parent != i)\n            subsets[i].parent = find(subsets, subsets[i].parent);\n        return subsets[i].parent;\n    }\n\n    void union(Subset subsets[], int x, int y) {\n        int xroot = find(subsets, x);\n        int yroot = find(subsets, y);\n        if (subsets[xroot].rank < subsets[yroot].rank)\n            subsets[xroot].parent = yroot;\n        else if (subsets[xroot].rank > subsets[yroot].rank)\n            subsets[yroot].parent = xroot;\n        else {\n            subsets[yroot].parent = xroot;\n            subsets[xroot].rank++;\n        }\n    }\n\n    void KruskalMST() {\n        Edge result[] = new Edge[V];\n        int e = 0;\n        int i = 0;\n        for (i = 0; i < V; ++i)\n            result[i] = new Edge();\n        Arrays.sort(edge);\n        Subset subsets[] = new Subset[V];\n        for (i = 0; i < V; ++i)\n            subsets[i] = new Subset();\n        for (int v = 0; v < V; ++v) {\n            subsets[v].parent = v;\n            subsets[v].rank = 0;\n        }\n        i = 0;\n        while (e < V - 1) {\n            Edge next_edge = new Edge();\n            next_edge = edge[i++];\n            int x = find(subsets, next_edge.src);\n            int y = find(subsets, next_edge.dest);\n            if (x != y) {\n                result[e++] = next_edge;\n                union(subsets, x, y);\n            }\n        }\n        for (i = 0; i < e; ++i)\n            System.out.println(result[i].src + \" - \" + result[i].dest + \" : \" + result[i].weight);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/C11i9JPRL14\" title=\"Kruskal&#39;s Algorithm Code Visualization\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Kruskal's Algorithm?",
        "options": ["A minimum spanning tree algorithm.", "A shortest path algorithm.", "A sorting algorithm."],
        "answer": "A minimum spanning tree algorithm."
      },
      {
        "question": "What is the time complexity of Kruskal's Algorithm?",
        "options": ["O(E log V)", "O(V^2)", "O(V log V)"],
        "answer": "O(E log V)"
      }
    ]
  },
  {
    "name": "Prim's Algorithm",
    "description": "Prim's Algorithm is a minimum spanning tree algorithm that starts with a single vertex and adds the cheapest possible connection from the tree to another vertex, one at a time until all vertices are included. It is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. [Learn more](https://en.wikipedia.org/wiki/Prim's_algorithm)",
    "code": {
      "python": "import heapq\n\ndef prim(graph, start):\n    mst = []\n    visited = set([start])\n    edges = [(cost, start, to) for to, cost in graph[start].items()]\n    heapq.heapify(edges)\n    while edges:\n        cost, frm, to = heapq.heappop(edges)\n        if to not in visited:\n            visited.add(to)\n            mst.append((frm, to, cost))\n            for to_next, cost in graph[to].items():\n                if to_next not in visited:\n                    heapq.heappush(edges, (cost, to, to_next))\n    return mst",
      "c++": "#include <iostream>\n#include <vector>\n#include <queue>\n\ntypedef std::pair<int, int> iPair;\n\nvoid primMST(std::vector<std::vector<iPair>>& adj, int V) {\n    std::priority_queue<iPair, std::vector<iPair>, std::greater<iPair>> pq;\n    int src = 0;\n    std::vector<int> key(V, INT_MAX);\n    std::vector<int> parent(V, -1);\n    std::vector<bool> inMST(V, false);\n    pq.push({0, src});\n    key[src] = 0;\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        inMST[u] = true;\n        for (auto& x : adj[u]) {\n            int v = x.first;\n            int weight = x.second;\n            if (!inMST[v] && key[v] > weight) {\n                key[v] = weight;\n                pq.push({key[v], v});\n                parent[v] = u;\n            }\n        }\n    }\n    for (int i = 1; i < V; ++i)\n        std::cout << parent[i] << \" - \" << i << \" : \" << key[i] << std::endl;\n}",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Edge>[] adj;\n\n    static class Edge {\n        int node;\n        int weight;\n        Edge(int node, int weight) { this.node = node; this.weight = weight; }\n    }\n\n    Graph(int V) {\n        this.V = V;\n        adj = new LinkedList[V];\n        for (int i = 0; i < V; ++i)\n            adj[i] = new LinkedList<>();\n    }\n\n    void addEdge(int u, int v, int weight) {\n        adj[u].add(new Edge(v, weight));\n        adj[v].add(new Edge(u, weight));\n    }\n\n    void primMST() {\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n        boolean[] inMST = new boolean[V];\n        Edge[] edgeTo = new Edge[V];\n        for (int i = 0; i < V; ++i)\n            edgeTo[i] = new Edge(-1, Integer.MAX_VALUE);\n        edgeTo[0].weight = 0;\n        pq.add(new Edge(0, 0));\n        while (!pq.isEmpty()) {\n            Edge edge = pq.poll();\n            int u = edge.node;\n            inMST[u] = true;\n            for (Edge neighbor : adj[u]) {\n                int v = neighbor.node;\n                int weight = neighbor.weight;\n                if (!inMST[v] && weight < edgeTo[v].weight) {\n                    edgeTo[v] = new Edge(u, weight);\n                    pq.add(new Edge(v, weight));\n                }\n            }\n        }\n        for (int i = 1; i < V; ++i)\n            System.out.println(edgeTo[i].node + \" - \" + i + \" : \" + edgeTo[i].weight);\n    }\n}"
    },
    "video": "<iframe width='900' height='500' src='https://www.youtube.com/embed/Ax-Kovi-BUk' title='Prim&#39;s Algorithm Code Visualization' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What type of algorithm is Prim's Algorithm?",
        "options": ["A minimum spanning tree algorithm.", "A shortest path algorithm.", "A sorting algorithm."],
        "answer": "A minimum spanning tree algorithm."
      },
      {
        "question": "What is the time complexity of Prim's Algorithm?",
        "options": ["O(E log V)", "O(V^2)", "O(V log V)"],
        "answer": "O(E log V)"
      }
    ]
  },
  {
    "name": "Fibonacci Sequence",
    "description": "The Fibonacci Sequence is a series of numbers in which each number (Fibonacci number) is the sum of the two preceding ones, usually starting with 0 and 1. The sequence appears in many different areas of mathematics and nature. [Learn more](https://en.wikipedia.org/wiki/Fibonacci_number)",
    "code": {
      "python": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
      "c++": "int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n-1) + fibonacci(n-2);\n}",
      "java": "int fibonacci(int n) {\n    if (n <= 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return fibonacci(n-1) + fibonacci(n-2);\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/hbveibMDHfg?list=TLPQMjUwNTIwMjT-UBBFCzY2ew\" title=\"Memoized Recursive Fibonacci Calls (Diagrammed)\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is the Fibonacci Sequence?",
        "options": ["A sequence where each number is the sum of the two preceding ones.", "A sequence where each number is twice the previous one.", "A sequence of prime numbers."],
        "answer": "A sequence where each number is the sum of the two preceding ones."
      },
      {
        "question": "What is the time complexity of the naive recursive Fibonacci algorithm?",
        "options": ["O(n)", "O(n^2)", "O(2^n)"],
        "answer": "O(2^n)"
      }
    ]
  },
  {
    "name": "Binary Search",
    "description": "Binary Search is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful or the remaining half is empty. [Learn more](https://en.wikipedia.org/wiki/Binary_search_algorithm)",
    "code": {
      "python": "def binarySearch(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return binarySearch(arr, l, mid-1, x)\n        else:\n            return binarySearch(arr, mid + 1, r, x)\n    else:\n        return -1",
      "c++": "int binarySearch(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}",
      "java": "int binarySearch(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/DRsJ8sA9xzc\" title=\"Binary Search animated\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is Binary Search?",
        "options": ["A search algorithm that finds the position of a target value within a sorted array.", "A search algorithm that finds the position of a target value within an unsorted array.", "A search algorithm that uses hashing to find the position of a target value."],
        "answer": "A search algorithm that finds the position of a target value within a sorted array."
      },
      {
        "question": "What is the time complexity of Binary Search?",
        "options": ["O(n)", "O(log n)", "O(n log n)"],
        "answer": "O(log n)"
      }
    ]
  },
  {
    "name": "KMP Algorithm (Knuth-Morris-Pratt)",
    "description": "The Knuth-Morris-Pratt (KMP) Algorithm is an efficient string matching algorithm that searches for occurrences of a word within a main text string by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin. [Learn more](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm)",
    "code": {
      "python": "def KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    lps = [0]*M\n    j = 0\n    computeLPSArray(pat, M, lps)\n    i = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        if j == M:\n            print(\"Found pattern at index \" + str(i-j))\n            j = lps[j-1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n\ndef computeLPSArray(pat, M, lps):\n    len = 0\n    lps[0] = 0\n    i = 1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            if len != 0:\n                len = lps[len-1]\n            else:\n                lps[i] = 0\n                i += 1",
      "c++": "void KMPSearch(const std::string& pat, const std::string& txt) {\n    int M = pat.size();\n    int N = txt.size();\n    std::vector<int> lps(M);\n    int j = 0;\n    computeLPSArray(pat, M, lps);\n    int i = 0;\n    while (i < N) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            std::cout << \"Found pattern at index \" << i - j << std::endl;\n            j = lps[j - 1];\n        } else if (i < N && pat[j] != txt[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n}\n\nvoid computeLPSArray(const std::string& pat, int M, std::vector<int>& lps) {\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0)\n                len = lps[len - 1];\n            else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}",
      "java": "void KMPSearch(String pat, String txt) {\n    int M = pat.length();\n    int N = txt.length();\n    int lps[] = new int[M];\n    int j = 0;\n    computeLPSArray(pat, M, lps);\n    int i = 0;\n    while (i < N) {\n        if (pat.charAt(j) == txt.charAt(i)) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            System.out.println(\"Found pattern at index \" + (i - j));\n            j = lps[j - 1];\n        } else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n}\n\nvoid computeLPSArray(String pat, int M, int lps[]) {\n    int len = 0;\n    lps[0] = 0;\n    int i = 1;\n    while (i < M) {\n        if (pat.charAt(i) == pat.charAt(len)) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0)\n                len = lps[len - 1];\n            else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/pu2aO_3R118\" title=\"Visualization of Knuth-Morris-Pratt Algorithm\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is the KMP Algorithm used for?",
        "options": ["Searching for occurrences of a substring within a main string.", "Sorting elements in an array.", "Finding the shortest path in a graph."],
        "answer": "Searching for occurrences of a substring within a main string."
      },
      {
        "question": "What is the time complexity of the KMP Algorithm?",
        "options": ["O(n)", "O(m + n)", "O(n log n)"],
        "answer": "O(m + n)"
      }
    ]
  },
  {
    "name": "Ternary Search",
    "description": "Ternary Search is a search algorithm that finds the position of a target value within a sorted array by dividing the array into three parts and determining which part to continue searching in. It is similar to binary search but instead of dividing the array into two parts, it divides it into three. [Learn more](https://en.wikipedia.org/wiki/Ternary_search)",
    "code": {
      "python": "def ternarySearch(l, r, key, ar):\n    if r >= l:\n        mid1 = l + (r - l) // 3\n        mid2 = r - (r - l) // 3\n        if ar[mid1] == key:\n            return mid1\n        if ar[mid2] == key:\n            return mid2\n        if key < ar[mid1]:\n            return ternarySearch(l, mid1 - 1, key, ar)\n        elif key > ar[mid2]:\n            return ternarySearch(mid2 + 1, r, key, ar)\n        else:\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar)\n    return -1",
      "c++": "int ternarySearch(int l, int r, int key, int ar[]) {\n    if (r >= l) {\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n        if (ar[mid1] == key)\n            return mid1;\n        if (ar[mid2] == key)\n            return mid2;\n        if (key < ar[mid1])\n            return ternarySearch(l, mid1 - 1, key, ar);\n        else if (key > ar[mid2])\n            return ternarySearch(mid2 + 1, r, key, ar);\n        else\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n    }\n    return -1;\n}",
      "java": "int ternarySearch(int l, int r, int key, int ar[]) {\n    if (r >= l) {\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n        if (ar[mid1] == key)\n            return mid1;\n        if (ar[mid2] == key)\n            return mid2;\n        if (key < ar[mid1])\n            return ternarySearch(l, mid1 - 1, key, ar);\n        else if (key > ar[mid2])\n            return ternarySearch(mid2 + 1, r, key, ar);\n        else\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n    }\n    return -1;\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/s1g_24NlinA\" title=\"Ternary Search Visualization\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is Ternary Search?",
        "options": ["A search algorithm that finds the position of a target value within a sorted array by dividing the array into three parts.", "A search algorithm that finds the position of a target value within an unsorted array.", "A search algorithm that uses hashing to find the position of a target value."],
        "answer": "A search algorithm that finds the position of a target value within a sorted array by dividing the array into three parts."
      },
      {
        "question": "What is the time complexity of Ternary Search?",
        "options": ["O(n)", "O(log n)", "O(log3 n)"],
        "answer": "O(log3 n)"
      }
    ]
  },
  {
    "name": "Bellman-Ford Algorithm",
    "description": "The Bellman-Ford Algorithm is a shortest path algorithm that computes the shortest paths from a single source vertex to all other vertices in a weighted digraph. It can handle graphs with negative weight edges, unlike Dijkstra's algorithm. [Learn more](https://en.wikipedia.org/wiki/Bellman–Ford_algorithm)",
    "code": {
      "python": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = []\n\n    def addEdge(self, u, v, w):\n        self.graph.append([u, v, w])\n\n    def BellmanFord(self, src):\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n        for _ in range(self.V - 1):\n            for u, v, w in self.graph:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n        for u, v, w in self.graph:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                print(\"Graph contains negative weight cycle\")\n                return\n        return dist",
      "c++": "class Graph {\n    int V;\n    std::vector<std::tuple<int, int, int>> edges;\npublic:\n    Graph(int V) : V(V) {}\n\n    void addEdge(int u, int v, int w) {\n        edges.push_back(std::make_tuple(u, v, w));\n    }\n\n    void BellmanFord(int src) {\n        std::vector<int> dist(V, INT_MAX);\n        dist[src] = 0;\n        for (int i = 1; i <= V - 1; i++) {\n            for (auto& edge : edges) {\n                int u, v, w;\n                std::tie(u, v, w) = edge;\n                if (dist[u] != INT_MAX && dist[u] + w < dist[v])\n                    dist[v] = dist[u] + w;\n            }\n        }\n        for (auto& edge : edges) {\n            int u, v, w;\n            std::tie(u, v, w) = edge;\n            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {\n                std::cout << \"Graph contains negative weight cycle\" << std::endl;\n                return;\n            }\n        }\n        for (int i = 0; i < V; ++i)\n            std::cout << \"Distance to node \" << i << \" is \" << dist[i] << std::endl;\n    }\n};",
      "java": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private LinkedList<Edge> edges;\n\n    class Edge {\n        int src, dest, weight;\n        Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; }\n    }\n\n    Graph(int V) {\n        this.V = V;\n        edges = new LinkedList<>();\n    }\n\n    void addEdge(int src, int dest, int weight) {\n        edges.add(new Edge(src, dest, weight));\n    }\n\n    void BellmanFord(int src) {\n        int dist[] = new int[V];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        for (int i = 1; i < V; ++i) {\n            for (Edge edge : edges) {\n                int u = edge.src;\n                int v = edge.dest;\n                int weight = edge.weight;\n                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])\n                    dist[v] = dist[u] + weight;\n            }\n        }\n        for (Edge edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            int weight = edge.weight;\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\n                System.out.println(\"Graph contains negative weight cycle\");\n                return;\n            }\n        }\n        for (int i = 0; i < V; ++i)\n            System.out.println(\"Distance to node \" + i + \" is \" + dist[i]);\n    }\n}"
    },
    "video": "<iframe width=\"900\" height=\"500\" src=\"https://www.youtube.com/embed/cpETrnfMkiY\" title=\"Bellman-Ford Algorithm: visualize and explain in one video\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>",
    "quiz": [
      {
        "question": "What is the Bellman-Ford Algorithm used for?",
        "options": ["Finding the shortest paths from a single source to all other vertices in a weighted graph.", "Finding the minimum spanning tree of a graph.", "Sorting elements in an array."],
        "answer": "Finding the shortest paths from a single source to all other vertices in a weighted graph."
      },
      {
        "question": "What is the time complexity of the Bellman-Ford Algorithm?",
        "options": ["O(V + E)", "O(V^2)", "O(VE)"],
        "answer": "O(VE)"
      }
    ]
  }
]
